0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\n//\r\n// Simple passthrough vertex shader\r\n//\r\nattribute vec3 in_Position; 
	// (x,y,z)\r\n//attribute vec3 in_Normal; 
	// (x,y,z) unused in this shader. \r\nattribute vec4 in_Colour; 
	// (r,g,b,a)\r\nattribute vec2 in_TextureCoord; 
	// (u,v)\r\n\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_vColour = in_Colour;\r\n 
	v_vTexcoord = in_TextureCoord;\r\n}\r\n\r\n 
	precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\n//\r\n// Simple passthrough fragment shader\r\n//\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\nuniform 
	float u_Distance;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 Color1 = texture2D( gm_BaseTexture, v_vTexcoord )/3.0;\r\n 
	vec4 Color2 = texture2D( gm_BaseTexture, v_vTexcoord+0.002*u_Distance )/3.0;\r\n 
	vec4 Color3 = texture2D( gm_BaseTexture, v_vTexcoord-0.002*u_Distance )/3.0;\r\n 
	Color1 *= 2.0;\r\n 
	Color2.g = 0.0;\r\n 
	Color2.b = 0.0;\r\n 
	Color3.r = 0.0;\r\n 
	gl_FragColor = v_vColour * (Color1 + Color2 + Color3);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\n//\r\n// Simple passthrough vertex shader\r\n//\r\nattribute vec3 in_Position; 
	// (x,y,z)\r\n//attribute vec3 in_Normal; 
	// (x,y,z) unused in this shader. \r\nattribute vec4 in_Colour; 
	// (r,g,b,a)\r\nattribute vec2 in_TextureCoord; 
	// (u,v)\r\n\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_vColour = in_Colour;\r\n 
	v_vTexcoord = in_TextureCoord;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\n//\r\n// Simple passthrough fragment shader\r\n//\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\nuniform 
	float u_Distance;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 Color1 = texture2D( gm_BaseTexture, v_vTexcoord )/3.0;\r\n 
	vec4 Color2 = texture2D( gm_BaseTexture, v_vTexcoord+0.002*u_Distance )/3.0;\r\n 
	vec4 Color3 = texture2D( gm_BaseTexture, v_vTexcoord-0.002*u_Distance )/3.0;\r\n 
	Color1 *= 2.0;\r\n 
	Color2.g = 0.0;\r\n 
	Color2.b = 0.0;\r\n 
	Color3.r = 0.0;\r\n 
	gl_FragColor = v_vColour * (Color1 + Color2 + Color3);\r\n}\r\n\r\n 
	#define MATRIX_VIEW 0\n#define MATRIX_PROJECTION 1\n#define MATRIX_WORLD 2\n#define MATRIX_WORLD_VIEW 3\n#define MATRIX_WORLD_VIEW_PROJECTION 4\n#define MATRICES_MAX 5\n\nfloat4x4 gm_Matrices[MATRICES_MAX] : register(c0);\n\nbool 
	gm_LightingEnabled;\nbool 
	gm_VS_FogEnabled;\nfloat 
	gm_FogStart;\nfloat 
	gm_RcpFogRange;\n\n#define 
	MAX_VS_LIGHTS 8\nfloat4 gm_AmbientColour; 
	// rgb=colour, a=1\nfloat3 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\nfloat4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\nfloat4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\n\n // GameMaker reserved and common types/inputs\n\nsampler2D gm_BaseTexture : register(S0);\n\nbool 
	gm_PS_FogEnabled;\nfloat4 
	gm_FogColour;\nbool 
	gm_AlphaTestEnabled;\nfloat4 
	gm_AlphaRefValue;\n 
	in_Position in_Colour in_TextureCoord shdBktGlitch #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\n//////////////////////////////////\r\n// -> FRAGMENT SHADER -> //\r\n// //\r\n// BktGlitch 1.1 //\r\n// Written by Blokatt //\r\n// (Jan Vorisek) //\r\n// @blokatt | blokatt.net //\r\n// jan@blokatt.net //\r\n// 13/09/2017 //\r\n// //\r\n// -> FRAGMENT SHADER -> //\r\n//////////////////////////////////\r\n\r\nattribute vec3 in_Position; 
	// (x,y,z)\r\nattribute vec4 in_Colour; 
	// (r,g,b,a)\r\nattribute vec2 in_TextureCoord; 
	// (u,v)\r\n\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	v_vColour = in_Colour;\r\n 
	v_vTexcoord = in_TextureCoord;\r\n}\r\n\r\n 
	precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\n//////////////////////////////////\r\n// //\r\n// BktGlitch 1.1 //\r\n// Written by Blokatt //\r\n// (Jan Vorisek) //\r\n// @blokatt | blokatt.net //\r\n// jan@blokatt.net //\r\n// 13/09/2017 //\r\n// //\r\n//////////////////////////////////\r\n\r\n/*\r\n\r\nSee Draw GUI of objControl for setup instructions.\r\nEasier example available in objSimpleExample, change the room order to see it in action.\r\n\r\nI recommend you use the provided setup GML scripts (see "BktGlitch" in Scripts) to control the\r\nshader rather then accessing the uniforms directly, this requires you run "BktGlitch_init()"\r\nat the start of the game. \r\n\r\nIf you don't want to set over 10 properties manually, you can use one of the available presets - see "BktGlitch_config_preset()".\r\n\r\nChanges:\r\n\r\n1.1 - increased compatibility with mobile devices\r\n\r\n*/\r\n\r\nprecision highp float; 
	//change to "mediump float;" 
	if you're having problems!\r\n\r\n#define PI 3.14159265359\r\n#define TAU 6.28318530718\r\n\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\n//MAIN 
	CONTROLLER UNIFORMS\r\nuniform float intensity; 
	//overall effect intensity, 0-1 (no upper limit)\r\nuniform float time; 
	//global timer variable\r\nuniform vec2 resolution; 
	//screen resolution, vector\r\nuniform float rngSeed; 
	//seed offset (changes configuration around)\r\n\r\n//TUNING\r\nuniform float lineSpeed; 
	//line speed\r\nuniform float lineDrift; 
	//horizontal line drifting\r\nuniform float lineResolution; 
	//line resolution\r\nuniform float lineVertShift; 
	//wave phase offset of horizontal lines\r\nuniform float lineShift; 
	//horizontal shift\r\nuniform float jumbleness; 
	//amount of "block" glitchiness\r\nuniform float jumbleResolution;//ŕesolution 
	of blocks\r\nuniform float jumbleShift; 
	//texture shift by blocks \r\nuniform float jumbleSpeed; 
	//speed of block variation\r\nuniform float dispersion; 
	//color channel horizontal dispersion\r\nuniform float channelShift; 
	//horizontal RGB shift\r\nuniform float noiseLevel; 
	//level of noise\r\nuniform float shakiness; 
	//horizontal shakiness\r\n//\r\n\r\nvec2 resRatios = normalize(resolution);\r\nfloat 
	tm = abs(time);\r\n\r\n//colour 
	extraction\r\n\r\nvec4 extractRed(vec4 col){\r\n 
	return vec4(col.r, 0., 0., col.a);\r\n}\r\n\r\nvec4 
	extractGreen(vec4 col){\r\n 
	return vec4(0., col.g, 0., col.a);\r\n}\r\n\r\nvec4 
	extractBlue(vec4 col){\r\n 
	return vec4(0., 0., col.b, col.a);\r\n}\r\n\r\n//coord 
	manipulation\r\n\r\nfloat saw(float v, float d){\r\n 
	return mod(v, d) * (d - floor(mod(v, d * 2.0)) * (d * 2.0)) + floor(mod(v, d * 2.0)); 
	\r\n}\r\n\r\nvec2 vec2LockIn(vec2 v){\r\n 
	return vec2(saw(v.x, 1.), saw(v.y, 1.));\r\n}\r\n\r\nvec2 
	shiftX(vec2 vec, float offset){\r\n 
	return vec2LockIn(vec2(vec.x + offset, vec.y));\r\n}\r\n\r\nfloat 
	tMod(float v, float d){\r\n 
	return mod(mod(v, d) + d, d); 
	\r\n}\r\n\r\nfloat downsample(float v, float res){\r\n 
	if (res == 0.0) return 0.0;\r\n 
	return floor(v * res) / res;\r\n}\r\n\r\n//RNG 
	function (uses improved version by Andy Gryc)\r\n\r\nhighp float rand(vec2 co)\r\n{\r\n 
	//highp vec2 _co = co + 1. + rngSeed;\r\n 
	highp vec2 _co = vec2(mod(co.x, resolution.x), mod(co.y, resolution.y));\r\n 
	highp float a = 12.9898;\r\n 
	highp float b = 78.233;\r\n 
	highp float c = 43758.5453;\r\n 
	highp float dt= dot(_co.xy, vec2(a,b));\r\n 
	highp float sn= mod(dt + rngSeed * .0001,3.14);\r\n 
	return fract(sin(sn) * c);\r\n}\r\n\r\n//jumble 
	generation\r\n\r\nfloat jumble(vec2 coord, float randOffset, float Resolution){\r\n 
	vec2 jumbleSubRes = vec2(Resolution, Resolution);\r\n 
	vec2 gridCoords = vec2(downsample(coord.x, jumbleSubRes.x / resRatios.y), downsample(coord.y, jumbleSubRes.y / resRatios.x));\r\n 
	vec2 gridCoordsSeed = vec2(downsample(coord.y, jumbleSubRes.x / resRatios.x), downsample(coord.x, jumbleSubRes.y / resRatios.y));\r\n 
	vec2LockIn(gridCoords);\r\n 
	vec2LockIn(gridCoordsSeed);\r\n 
	float shift = rand(randOffset + gridCoords + downsample(tm * .02 + intensity, jumbleSpeed));\r\n 
	return ((((shift - .5)) * downsample(intensity, 10.) * jumbleShift) * floor(rand(randOffset + gridCoordsSeed + downsample(tm * .02 + intensity, jumbleSpeed)) + jumbleness));\r\n}\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 outColour;\r\n 
	vec2 coords = v_vTexcoord;\r\n 
	\r\n //base line shift\r\n float dY = downsample(v_vTexcoord.y, 50. * lineResolution);\r\n 
	float wave0 = sin((downsample(rand(vec2(dY, dY)) * TAU, 50. * lineResolution) * 80. + tm * lineSpeed) + lineVertShift * TAU);\r\n 
	dY = downsample(v_vTexcoord.y, 25. * lineResolution);\r\n 
	float wave1 = cos((downsample(rand(vec2(dY, dY)) * TAU, 25. * lineResolution) * 80. + tm * lineSpeed) + lineVertShift * TAU);\r\n 
	float driftSin = resolution.y * 2.778;\r\n 
	coords = shiftX(coords,(wave0 * (1. + rand(vec2(wave0, wave0)) * shakiness) +\r\n wave1 * (1. + rand(vec2(wave1, wave1)) * shakiness) +\r\n sin((v_vTexcoord.y * (driftSin) + 2. + tm * lineSpeed) + lineVertShift * TAU) * lineDrift + \r\n rand(coords + tm) * lineSpeed * shakiness + \r\n cos((v_vTexcoord.y * (driftSin * .1) + 1. + tm * lineSpeed) + lineVertShift * TAU) * lineDrift) * lineShift * intensity);\r\n 
	\r\n //jumbles\r\n coords.y += jumble(coords, 0., jumbleResolution * 100.) * intensity * .25;\r\n 
	coords.x += jumble(coords, .25, jumbleResolution * 100.) * intensity * .25;\r\n 
	\r\n //avoid coord clamping\r\n coords = vec2LockIn(coords); 
	\r\n \r\n //channel split\r\n outColour = extractRed(texture2D( gm_BaseTexture, shiftX(coords, (channelShift + rand(coords) * dispersion) * intensity))) +\r\n extractBlue(texture2D( gm_BaseTexture, shiftX(coords, -(channelShift + rand(coords) * dispersion) * intensity))) +\r\n extractGreen(texture2D( gm_BaseTexture, coords));\r\n 
	\r\n //add noise\r\n outColour.r *= 1. + (rand(tm * coords * 2.)) * intensity * noiseLevel * .55;\r\n 
	outColour.g *= 1. + (rand(tm * coords)) * intensity * noiseLevel * .5;\r\n 
	outColour.b *= 1. + (rand(tm * coords * 3.)) * intensity * noiseLevel * .4;\r\n 
	\r\n //set fragment colour\r\n gl_FragColor = v_vColour * outColour;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\n//////////////////////////////////\r\n// -> FRAGMENT SHADER -> //\r\n// //\r\n// BktGlitch 1.1 //\r\n// Written by Blokatt //\r\n// (Jan Vorisek) //\r\n// @blokatt | blokatt.net //\r\n// jan@blokatt.net //\r\n// 13/09/2017 //\r\n// //\r\n// -> FRAGMENT SHADER -> //\r\n//////////////////////////////////\r\n\r\nattribute vec3 in_Position; 
	// (x,y,z)\r\nattribute vec4 in_Colour; 
	// (r,g,b,a)\r\nattribute vec2 in_TextureCoord; 
	// (u,v)\r\n\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	v_vColour = in_Colour;\r\n 
	v_vTexcoord = in_TextureCoord;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\n//////////////////////////////////\r\n// //\r\n// BktGlitch 1.1 //\r\n// Written by Blokatt //\r\n// (Jan Vorisek) //\r\n// @blokatt | blokatt.net //\r\n// jan@blokatt.net //\r\n// 13/09/2017 //\r\n// //\r\n//////////////////////////////////\r\n\r\n/*\r\n\r\nSee Draw GUI of objControl for setup instructions.\r\nEasier example available in objSimpleExample, change the room order to see it in action.\r\n\r\nI recommend you use the provided setup GML scripts (see "BktGlitch" in Scripts) to control the\r\nshader rather then accessing the uniforms directly, this requires you run "BktGlitch_init()"\r\nat the start of the game. \r\n\r\nIf you don't want to set over 10 properties manually, you can use one of the available presets - see "BktGlitch_config_preset()".\r\n\r\nChanges:\r\n\r\n1.1 - increased compatibility with mobile devices\r\n\r\n*/\r\n\r\nprecision highp float; 
	//change to "mediump float;" 
	if you're having problems!\r\n\r\n#define PI 3.14159265359\r\n#define TAU 6.28318530718\r\n\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\n//MAIN 
	CONTROLLER UNIFORMS\r\nuniform float intensity; 
	//overall effect intensity, 0-1 (no upper limit)\r\nuniform float time; 
	//global timer variable\r\nuniform vec2 resolution; 
	//screen resolution, vector\r\nuniform float rngSeed; 
	//seed offset (changes configuration around)\r\n\r\n//TUNING\r\nuniform float lineSpeed; 
	//line speed\r\nuniform float lineDrift; 
	//horizontal line drifting\r\nuniform float lineResolution; 
	//line resolution\r\nuniform float lineVertShift; 
	//wave phase offset of horizontal lines\r\nuniform float lineShift; 
	//horizontal shift\r\nuniform float jumbleness; 
	//amount of "block" glitchiness\r\nuniform float jumbleResolution;//ŕesolution 
	of blocks\r\nuniform float jumbleShift; 
	//texture shift by blocks \r\nuniform float jumbleSpeed; 
	//speed of block variation\r\nuniform float dispersion; 
	//color channel horizontal dispersion\r\nuniform float channelShift; 
	//horizontal RGB shift\r\nuniform float noiseLevel; 
	//level of noise\r\nuniform float shakiness; 
	//horizontal shakiness\r\n//\r\n\r\nvec2 resRatios = normalize(resolution);\r\nfloat 
	tm = abs(time);\r\n\r\n//colour 
	extraction\r\n\r\nvec4 extractRed(vec4 col){\r\n 
	return vec4(col.r, 0., 0., col.a);\r\n}\r\n\r\nvec4 
	extractGreen(vec4 col){\r\n 
	return vec4(0., col.g, 0., col.a);\r\n}\r\n\r\nvec4 
	extractBlue(vec4 col){\r\n 
	return vec4(0., 0., col.b, col.a);\r\n}\r\n\r\n//coord 
	manipulation\r\n\r\nfloat saw(float v, float d){\r\n 
	return mod(v, d) * (d - floor(mod(v, d * 2.0)) * (d * 2.0)) + floor(mod(v, d * 2.0)); 
	\r\n}\r\n\r\nvec2 vec2LockIn(vec2 v){\r\n 
	return vec2(saw(v.x, 1.), saw(v.y, 1.));\r\n}\r\n\r\nvec2 
	shiftX(vec2 vec, float offset){\r\n 
	return vec2LockIn(vec2(vec.x + offset, vec.y));\r\n}\r\n\r\nfloat 
	tMod(float v, float d){\r\n 
	return mod(mod(v, d) + d, d); 
	\r\n}\r\n\r\nfloat downsample(float v, float res){\r\n 
	if (res == 0.0) return 0.0;\r\n 
	return floor(v * res) / res;\r\n}\r\n\r\n//RNG 
	function (uses improved version by Andy Gryc)\r\n\r\nhighp float rand(vec2 co)\r\n{\r\n 
	//highp vec2 _co = co + 1. + rngSeed;\r\n 
	highp vec2 _co = vec2(mod(co.x, resolution.x), mod(co.y, resolution.y));\r\n 
	highp float a = 12.9898;\r\n 
	highp float b = 78.233;\r\n 
	highp float c = 43758.5453;\r\n 
	highp float dt= dot(_co.xy, vec2(a,b));\r\n 
	highp float sn= mod(dt + rngSeed * .0001,3.14);\r\n 
	return fract(sin(sn) * c);\r\n}\r\n\r\n//jumble 
	generation\r\n\r\nfloat jumble(vec2 coord, float randOffset, float Resolution){\r\n 
	vec2 jumbleSubRes = vec2(Resolution, Resolution);\r\n 
	vec2 gridCoords = vec2(downsample(coord.x, jumbleSubRes.x / resRatios.y), downsample(coord.y, jumbleSubRes.y / resRatios.x));\r\n 
	vec2 gridCoordsSeed = vec2(downsample(coord.y, jumbleSubRes.x / resRatios.x), downsample(coord.x, jumbleSubRes.y / resRatios.y));\r\n 
	vec2LockIn(gridCoords);\r\n 
	vec2LockIn(gridCoordsSeed);\r\n 
	float shift = rand(randOffset + gridCoords + downsample(tm * .02 + intensity, jumbleSpeed));\r\n 
	return ((((shift - .5)) * downsample(intensity, 10.) * jumbleShift) * floor(rand(randOffset + gridCoordsSeed + downsample(tm * .02 + intensity, jumbleSpeed)) + jumbleness));\r\n}\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 outColour;\r\n 
	vec2 coords = v_vTexcoord;\r\n 
	\r\n //base line shift\r\n float dY = downsample(v_vTexcoord.y, 50. * lineResolution);\r\n 
	float wave0 = sin((downsample(rand(vec2(dY, dY)) * TAU, 50. * lineResolution) * 80. + tm * lineSpeed) + lineVertShift * TAU);\r\n 
	dY = downsample(v_vTexcoord.y, 25. * lineResolution);\r\n 
	float wave1 = cos((downsample(rand(vec2(dY, dY)) * TAU, 25. * lineResolution) * 80. + tm * lineSpeed) + lineVertShift * TAU);\r\n 
	float driftSin = resolution.y * 2.778;\r\n 
	coords = shiftX(coords,(wave0 * (1. + rand(vec2(wave0, wave0)) * shakiness) +\r\n wave1 * (1. + rand(vec2(wave1, wave1)) * shakiness) +\r\n sin((v_vTexcoord.y * (driftSin) + 2. + tm * lineSpeed) + lineVertShift * TAU) * lineDrift + \r\n rand(coords + tm) * lineSpeed * shakiness + \r\n cos((v_vTexcoord.y * (driftSin * .1) + 1. + tm * lineSpeed) + lineVertShift * TAU) * lineDrift) * lineShift * intensity);\r\n 
	\r\n //jumbles\r\n coords.y += jumble(coords, 0., jumbleResolution * 100.) * intensity * .25;\r\n 
	coords.x += jumble(coords, .25, jumbleResolution * 100.) * intensity * .25;\r\n 
	\r\n //avoid coord clamping\r\n coords = vec2LockIn(coords); 
	\r\n \r\n //channel split\r\n outColour = extractRed(texture2D( gm_BaseTexture, shiftX(coords, (channelShift + rand(coords) * dispersion) * intensity))) +\r\n extractBlue(texture2D( gm_BaseTexture, shiftX(coords, -(channelShift + rand(coords) * dispersion) * intensity))) +\r\n extractGreen(texture2D( gm_BaseTexture, coords));\r\n 
	\r\n //add noise\r\n outColour.r *= 1. + (rand(tm * coords * 2.)) * intensity * noiseLevel * .55;\r\n 
	outColour.g *= 1. + (rand(tm * coords)) * intensity * noiseLevel * .5;\r\n 
	outColour.b *= 1. + (rand(tm * coords * 3.)) * intensity * noiseLevel * .4;\r\n 
	\r\n //set fragment colour\r\n gl_FragColor = v_vColour * outColour;\r\n}\r\n\r\n 
	sh_radial_blur #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio); 
	\r\n}\r\n\r\n precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	float u_amplitude;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 blur = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 16;\r\n 
	\r\n float stp = (1.0 / float(SAMPLES));\r\n 
	\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float amp = (u_amplitude / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = amp;\r\n 
	highp float shift_y = amp;\r\n 
	\r\n highp vec2 shiftUV = v_uv0 + (vec2(shift_x, shift_y) * ((1.0 - v_uv0) * 2.0 -1.0) * vec2(1.0, u_vRatio));\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / float(SAMPLES);\r\n 
	}\r\n \r\n vec4 Complete = blur;\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio); 
	\r\n}\r\n\r\n #version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	float u_amplitude;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 blur = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 16;\r\n 
	\r\n float stp = (1.0 / float(SAMPLES));\r\n 
	\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float amp = (u_amplitude / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = amp;\r\n 
	highp float shift_y = amp;\r\n 
	\r\n highp vec2 shiftUV = v_uv0 + (vec2(shift_x, shift_y) * ((1.0 - v_uv0) * 2.0 -1.0) * vec2(1.0, u_vRatio));\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / float(SAMPLES);\r\n 
	}\r\n \r\n vec4 Complete = blur;\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	sh_brightness precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\nuniform 
	float Position;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 Colour = texture2D( gm_BaseTexture, v_vTexcoord ); 
	// get colour of pixel\r\n // add brightness to pixel that depends on Position uniform\r\n Colour.r += Position; 
	// for red channel\r\n Colour.g += Position; 
	// for green channel\r\n Colour.b += Position; 
	// for blue channel\r\n gl_FragColor = v_vColour * Colour;\r\n}\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\nuniform 
	float Position;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 Colour = texture2D( gm_BaseTexture, v_vTexcoord ); 
	// get colour of pixel\r\n // add brightness to pixel that depends on Position uniform\r\n Colour.r += Position; 
	// for red channel\r\n Colour.g += Position; 
	// for green channel\r\n Colour.b += Position; 
	// for blue channel\r\n gl_FragColor = v_vColour * Colour;\r\n}\r\n 
	shader_bloom #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio); 
	\r\n}\r\n\r\n precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_threshold;\r\nuniform 
	float u_radius;\r\nuniform 
	float u_amount;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 bloom = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 16;\r\n\r\n 
	for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_radius;\r\n 
	highp float shift_y = sin(angle) * u_radius;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n vec4 col = texture2D(gm_BaseTexture, shiftUV);\r\n 
	col -= u_threshold;\r\n 
	col = max(col, vec4(0.0)); 
	\r\n //col *= col;\r\n 
	\r\n \r\n bloom += col/ float(SAMPLES);\r\n 
	}\r\n \r\n vec4 DF = texture2D(gm_BaseTexture, v_uv0);\r\n 
	\r\n vec4 Complete = DF + (bloom * u_amount);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio); 
	\r\n}\r\n\r\n #version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_threshold;\r\nuniform 
	float u_radius;\r\nuniform 
	float u_amount;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 bloom = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 16;\r\n\r\n 
	for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_radius;\r\n 
	highp float shift_y = sin(angle) * u_radius;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n vec4 col = texture2D(gm_BaseTexture, shiftUV);\r\n 
	col -= u_threshold;\r\n 
	col = max(col, vec4(0.0)); 
	\r\n //col *= col;\r\n 
	\r\n \r\n bloom += col/ float(SAMPLES);\r\n 
	}\r\n \r\n vec4 DF = texture2D(gm_BaseTexture, v_uv0);\r\n 
	\r\n vec4 Complete = DF + (bloom * u_amount);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	shader_blur precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_threshold;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 blur = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 8;\r\n\r\n 
	for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_threshold;\r\n 
	highp float shift_y = sin(angle) * u_threshold;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / float(SAMPLES);\r\n 
	}\r\n \r\n vec4 Complete = blur;\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_threshold;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 blur = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 8;\r\n\r\n 
	for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_threshold;\r\n 
	highp float shift_y = sin(angle) * u_threshold;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / float(SAMPLES);\r\n 
	}\r\n \r\n vec4 Complete = blur;\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	shader_bokeh precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nuniform 
	float u_threshold;\r\nuniform 
	float u_radius;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 bloom = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n //first circle\r\n int SAMPLES = 16;\r\n\r\n 
	for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_radius;\r\n 
	highp float shift_y = sin(angle) * u_radius;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n vec4 col = texture2D(gm_BaseTexture, shiftUV);\r\n 
	col -= u_threshold;\r\n 
	col = max(col, vec4(0.0)); 
	\r\n \r\n bloom += col/ float(SAMPLES);\r\n 
	}\r\n \r\n //second circle \r\n highp float offset = circle / float(SAMPLES) * 0.5;\r\n 
	\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_radius * 0.5;\r\n 
	highp float shift_y = sin(angle) * u_radius * 0.5;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n vec4 col = texture2D(gm_BaseTexture, shiftUV);\r\n 
	col -= u_threshold;\r\n 
	col = max(col, vec4(0.0)); 
	\r\n \r\n bloom += col/ float(SAMPLES);\r\n 
	}\r\n \r\n float bloomLum = dot(bloom.rgb, vec3(0.333));\r\n 
	bloomLum *= 10.0;\r\n 
	\r\n vec4 DF = texture2D(gm_BaseTexture, v_uv0) * 0.5;\r\n 
	//DF.rgb = pow(DF.rgb, vec3(2.0));\r\n 
	\r\n vec4 BK = texture2D(sampler0, v_uv0Ratio);\r\n 
	\r\n vec4 Complete = DF + (BK * bloomLum);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nuniform 
	float u_threshold;\r\nuniform 
	float u_radius;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 bloom = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n //first circle\r\n int SAMPLES = 16;\r\n\r\n 
	for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_radius;\r\n 
	highp float shift_y = sin(angle) * u_radius;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n vec4 col = texture2D(gm_BaseTexture, shiftUV);\r\n 
	col -= u_threshold;\r\n 
	col = max(col, vec4(0.0)); 
	\r\n \r\n bloom += col/ float(SAMPLES);\r\n 
	}\r\n \r\n //second circle \r\n highp float offset = circle / float(SAMPLES) * 0.5;\r\n 
	\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_radius * 0.5;\r\n 
	highp float shift_y = sin(angle) * u_radius * 0.5;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n vec4 col = texture2D(gm_BaseTexture, shiftUV);\r\n 
	col -= u_threshold;\r\n 
	col = max(col, vec4(0.0)); 
	\r\n \r\n bloom += col/ float(SAMPLES);\r\n 
	}\r\n \r\n float bloomLum = dot(bloom.rgb, vec3(0.333));\r\n 
	bloomLum *= 10.0;\r\n 
	\r\n vec4 DF = texture2D(gm_BaseTexture, v_uv0) * 0.5;\r\n 
	//DF.rgb = pow(DF.rgb, vec3(2.0));\r\n 
	\r\n vec4 BK = texture2D(sampler0, v_uv0Ratio);\r\n 
	\r\n vec4 Complete = DF + (BK * bloomLum);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	shader_colorMapping precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{\r\n 
	\r\n vec4 col = texture2D(gm_BaseTexture, v_uv0);\r\n 
	\r\n float col_R = texture2D(sampler0, vec2(col.r,0.5)).r;\r\n 
	float col_G = texture2D(sampler0, vec2(col.g,0.5)).g;\r\n 
	float col_B = texture2D(sampler0, vec2(col.b,0.5)).b;\r\n 
	\r\n vec4 Complete = vec4(col_R, col_G, col_B, 1.0);\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{\r\n 
	\r\n vec4 col = texture2D(gm_BaseTexture, v_uv0);\r\n 
	\r\n float col_R = texture2D(sampler0, vec2(col.r,0.5)).r;\r\n 
	float col_G = texture2D(sampler0, vec2(col.g,0.5)).g;\r\n 
	float col_B = texture2D(sampler0, vec2(col.b,0.5)).b;\r\n 
	\r\n vec4 Complete = vec4(col_R, col_G, col_B, 1.0);\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	shader_crystallize #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord;\r\n 
	v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio); 
	\r\n}\r\n\r\n precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nuniform sampler2D sampler0;\r\n\r\nuniform 
	float u_distAmount;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n vec4 NM = texture2D( sampler0, v_uv0Ratio );\r\n 
	\r\n vec2 newUv = v_uv0 + ((NM.rg * 2.0 - 1.0) * u_distAmount);\r\n 
	\r\n vec4 DF = texture2D( gm_BaseTexture, newUv) + NM.b;\r\n 
	\r\n gl_FragColor = vec4(DF.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord;\r\n 
	v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio); 
	\r\n}\r\n\r\n #version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nuniform sampler2D sampler0;\r\n\r\nuniform 
	float u_distAmount;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n vec4 NM = texture2D( sampler0, v_uv0Ratio );\r\n 
	\r\n vec2 newUv = v_uv0 + ((NM.rg * 2.0 - 1.0) * u_distAmount);\r\n 
	\r\n vec4 DF = texture2D( gm_BaseTexture, newUv) + NM.b;\r\n 
	\r\n gl_FragColor = vec4(DF.rgb, 1.0);\r\n}\r\n\r\n 
	shader_DOF precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_scale;\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float piNum = 3.14159265359;\r\n 
	float circle = 2.0 * piNum;\r\n 
	\r\n vec4 blur = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 8;\r\n 
	\r\n //1st pass...\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_scale;\r\n 
	highp float shift_y = sin(angle) * u_scale;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / (float(SAMPLES) * 2.0);\r\n 
	}\r\n \r\n //2nd pass...\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_scale * 0.5;\r\n 
	highp float shift_y = sin(angle) * u_scale * 0.5;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / (float(SAMPLES) * 2.0);\r\n 
	}\r\n \r\n //mix calculation\r\n vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	vec4 MK = texture2D( sampler0, v_uv0Ratio );\r\n 
	\r\n vec4 Complete = mix(blur, DF, MK.r);\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_scale;\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float piNum = 3.14159265359;\r\n 
	float circle = 2.0 * piNum;\r\n 
	\r\n vec4 blur = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 8;\r\n 
	\r\n //1st pass...\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_scale;\r\n 
	highp float shift_y = sin(angle) * u_scale;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / (float(SAMPLES) * 2.0);\r\n 
	}\r\n \r\n //2nd pass...\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_scale * 0.5;\r\n 
	highp float shift_y = sin(angle) * u_scale * 0.5;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / (float(SAMPLES) * 2.0);\r\n 
	}\r\n \r\n //mix calculation\r\n vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	vec4 MK = texture2D( sampler0, v_uv0Ratio );\r\n 
	\r\n vec4 Complete = mix(blur, DF, MK.r);\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	shader_duoTone #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio);\r\n}\r\n\r\n 
	precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	vec3 u_colorA;\r\nuniform 
	vec3 u_colorB;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	vec3 weights = vec3( 0.3, 0.59, 0.11);\r\n 
	float lum = dot(DF.rgb, weights);\r\n 
	\r\n vec4 Complete = vec4(1.0,1.0,1.0,1.0);\r\n 
	Complete.rgb = mix(u_colorA, u_colorB, lum);\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	vec3 u_colorA;\r\nuniform 
	vec3 u_colorB;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	vec3 weights = vec3( 0.3, 0.59, 0.11);\r\n 
	float lum = dot(DF.rgb, weights);\r\n 
	\r\n vec4 Complete = vec4(1.0,1.0,1.0,1.0);\r\n 
	Complete.rgb = mix(u_colorA, u_colorB, lum);\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	shader_fog #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	float u_speed;\r\nuniform 
	float u_time;\r\nuniform 
	float u_fogScale;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio);\r\n 
	v_uv0Mov = (in_TextureCoord + vec2(u_speed,0.0) * u_time) * vec2(1.0, u_vRatio);\r\n 
	v_uv0Mov.x *= u_fogScale; 
	//stretch the fog\r\n}\r\n\r\n precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\nuniform 
	sampler2D sampler1;\r\n\r\nuniform 
	vec3 u_fogColor;\r\nuniform 
	float u_distAmount;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	vec4 NM = texture2D( sampler1, v_uv0Ratio ) * 2.0 - 1.0;\r\n 
	vec2 FG_coords = v_uv0Mov + (NM.rg * u_distAmount);\r\n 
	\r\n vec4 FG = texture2D( sampler0, FG_coords );\r\n 
	\r\n vec3 Complete = mix(DF.rgb, FG.rgb * u_fogColor, FG.a);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	float u_speed;\r\nuniform 
	float u_time;\r\nuniform 
	float u_fogScale;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio);\r\n 
	v_uv0Mov = (in_TextureCoord + vec2(u_speed,0.0) * u_time) * vec2(1.0, u_vRatio);\r\n 
	v_uv0Mov.x *= u_fogScale; 
	//stretch the fog\r\n}\r\n\r\n #version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\nuniform 
	sampler2D sampler1;\r\n\r\nuniform 
	vec3 u_fogColor;\r\nuniform 
	float u_distAmount;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	vec4 NM = texture2D( sampler1, v_uv0Ratio ) * 2.0 - 1.0;\r\n 
	vec2 FG_coords = v_uv0Mov + (NM.rg * u_distAmount);\r\n 
	\r\n vec4 FG = texture2D( sampler0, FG_coords );\r\n 
	\r\n vec3 Complete = mix(DF.rgb, FG.rgb * u_fogColor, FG.a);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	shader_foreground #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	float u_speed;\r\nuniform 
	float u_time;\r\nuniform 
	float u_scale;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Mov = (in_TextureCoord + vec2(u_speed,0.0) * u_time) * vec2(1.0, u_vRatio);\r\n 
	v_uv0Mov.x *= u_scale; 
	//stretch the foreground\r\n}\r\n\r\n precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\n\r\nuniform 
	sampler2D sampler0;\r\nuniform 
	sampler2D sampler1;\r\n\r\nuniform 
	vec3 u_color;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	\r\n vec4 FG = texture2D( sampler0, v_uv0Mov );\r\n 
	\r\n vec3 Complete = mix(DF.rgb, u_color, FG.r);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	float u_speed;\r\nuniform 
	float u_time;\r\nuniform 
	float u_scale;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Mov = (in_TextureCoord + vec2(u_speed,0.0) * u_time) * vec2(1.0, u_vRatio);\r\n 
	v_uv0Mov.x *= u_scale; 
	//stretch the foreground\r\n}\r\n\r\n #version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\n\r\nuniform 
	sampler2D sampler0;\r\nuniform 
	sampler2D sampler1;\r\n\r\nuniform 
	vec3 u_color;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	\r\n vec4 FG = texture2D( sampler0, v_uv0Mov );\r\n 
	\r\n vec3 Complete = mix(DF.rgb, u_color, FG.r);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	shader_glitter precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	float u_amplitude;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float piNum = 3.14159265359;\r\n 
	float circle = 2.0 * piNum;\r\n 
	\r\n float lightShaft = 0.0;\r\n 
	\r\n int SAMPLES = 16;\r\n 
	\r\n float stp = (1.0 / float(SAMPLES));\r\n 
	\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n { 
	\r\n float modulator = (1.0 - float(i) / float(SAMPLES)) * 2.0 - 1.0;\r\n 
	\r\n float shift_x = modulator * u_amplitude;\r\n 
	float shift_y = modulator * u_amplitude;\r\n 
	\r\n //diagonal 1\r\n vec2 shiftUV1 = v_uv0 + vec2(shift_x, -shift_y);\r\n 
	vec4 DF1 = texture2D(gm_BaseTexture, shiftUV1);\r\n 
	\r\n float lum1 = dot(DF1.rgb, vec3( 0.2126, 0.7152, 0.0722));\r\n 
	float glare1 = pow(abs(lum1), 12.0); 
	\r\n glare1 = glare1 * (1.0 - abs(modulator));\r\n 
	glare1 = glare1 / (float(SAMPLES));\r\n 
	\r\n //diagonal 2\r\n vec2 shiftUV2 = v_uv0 + vec2(shift_y, shift_x);\r\n 
	vec4 DF2 = texture2D(gm_BaseTexture, shiftUV2);\r\n 
	\r\n float lum2 = dot(DF2.rgb, vec3( 0.2126, 0.7152, 0.0722));\r\n 
	float glare2 = pow(abs(lum2), 12.0); 
	\r\n glare2 = glare2 * (1.0 - abs(modulator));\r\n 
	glare2 = glare2 / (float(SAMPLES));\r\n 
	\r\n lightShaft += glare1;\r\n 
	lightShaft += glare2;\r\n 
	}\r\n \r\n vec4 Complete = texture2D(gm_BaseTexture, v_uv0) + (lightShaft * 5.0);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	float u_amplitude;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float piNum = 3.14159265359;\r\n 
	float circle = 2.0 * piNum;\r\n 
	\r\n float lightShaft = 0.0;\r\n 
	\r\n int SAMPLES = 16;\r\n 
	\r\n float stp = (1.0 / float(SAMPLES));\r\n 
	\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n { 
	\r\n float modulator = (1.0 - float(i) / float(SAMPLES)) * 2.0 - 1.0;\r\n 
	\r\n float shift_x = modulator * u_amplitude;\r\n 
	float shift_y = modulator * u_amplitude;\r\n 
	\r\n //diagonal 1\r\n vec2 shiftUV1 = v_uv0 + vec2(shift_x, -shift_y);\r\n 
	vec4 DF1 = texture2D(gm_BaseTexture, shiftUV1);\r\n 
	\r\n float lum1 = dot(DF1.rgb, vec3( 0.2126, 0.7152, 0.0722));\r\n 
	float glare1 = pow(abs(lum1), 12.0); 
	\r\n glare1 = glare1 * (1.0 - abs(modulator));\r\n 
	glare1 = glare1 / (float(SAMPLES));\r\n 
	\r\n //diagonal 2\r\n vec2 shiftUV2 = v_uv0 + vec2(shift_y, shift_x);\r\n 
	vec4 DF2 = texture2D(gm_BaseTexture, shiftUV2);\r\n 
	\r\n float lum2 = dot(DF2.rgb, vec3( 0.2126, 0.7152, 0.0722));\r\n 
	float glare2 = pow(abs(lum2), 12.0); 
	\r\n glare2 = glare2 * (1.0 - abs(modulator));\r\n 
	glare2 = glare2 / (float(SAMPLES));\r\n 
	\r\n lightShaft += glare1;\r\n 
	lightShaft += glare2;\r\n 
	}\r\n \r\n vec4 Complete = texture2D(gm_BaseTexture, v_uv0) + (lightShaft * 5.0);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	shader_heatDistortion precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec2 MK = texture2D( sampler0, v_uv0Ratio ).rg * 2.0 - 1.0;\r\n 
	\r\n float thres = 0.01;\r\n 
	\r\n vec2 uv_dist = v_uv0 + (MK * thres);\r\n 
	\r\n vec4 Complete = texture2D( gm_BaseTexture, uv_dist );\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec2 MK = texture2D( sampler0, v_uv0Ratio ).rg * 2.0 - 1.0;\r\n 
	\r\n float thres = 0.01;\r\n 
	\r\n vec2 uv_dist = v_uv0 + (MK * thres);\r\n 
	\r\n vec4 Complete = texture2D( gm_BaseTexture, uv_dist );\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	shader_hiContrast #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio);\r\n}\r\n\r\n 
	precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_threshold;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	\r\n vec4 DF_cont = DF * DF + DF;\r\n 
	\r\n vec4 Complete = mix(DF, DF_cont, u_threshold);\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_threshold;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	\r\n vec4 DF_cont = DF * DF + DF;\r\n 
	\r\n vec4 Complete = mix(DF, DF_cont, u_threshold);\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	shader_magnify precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_threshold;\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec2 MK = texture2D( sampler0, v_uv0Ratio ).rg * 2.0 - 1.0;\r\n 
	\r\n vec2 uv_dist = v_uv0 + (MK * u_threshold);\r\n 
	\r\n vec4 Complete = texture2D( gm_BaseTexture, uv_dist );\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_threshold;\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec2 MK = texture2D( sampler0, v_uv0Ratio ).rg * 2.0 - 1.0;\r\n 
	\r\n vec2 uv_dist = v_uv0 + (MK * u_threshold);\r\n 
	\r\n vec4 Complete = texture2D( gm_BaseTexture, uv_dist );\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	shader_motionBlur precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\n\r\nuniform 
	float u_amplitude;\r\nuniform 
	float u_angle;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 blur = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 16;\r\n 
	\r\n float stp = (1.0 / float(SAMPLES));\r\n 
	\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float amp = (u_amplitude / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(u_angle) * amp;\r\n 
	highp float shift_y = sin(u_angle) * amp;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / float(SAMPLES);\r\n 
	}\r\n \r\n vec4 Complete = blur;\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\n\r\nuniform 
	float u_amplitude;\r\nuniform 
	float u_angle;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 blur = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 16;\r\n 
	\r\n float stp = (1.0 / float(SAMPLES));\r\n 
	\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float amp = (u_amplitude / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(u_angle) * amp;\r\n 
	highp float shift_y = sin(u_angle) * amp;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / float(SAMPLES);\r\n 
	}\r\n \r\n vec4 Complete = blur;\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	shader_oldMovie #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	float u_speedX;\r\nuniform 
	float u_speedY;\r\nuniform 
	float u_time;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio);\r\n 
	v_uv0Mov = (in_TextureCoord + vec2(u_speedX,u_speedY) * u_time) * vec2(1.0, u_vRatio);\r\n}\r\n\r\n 
	precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\nuniform 
	sampler2D sampler1;\r\n\r\nuniform 
	vec3 u_movieColor;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	vec4 dirt = texture2D( sampler0, v_uv0Mov );\r\n 
	vec4 vignette = texture2D( sampler1, v_uv0Ratio );\r\n 
	\r\n vec3 weights = vec3( 0.95, 0.95, 0.95); 
	//vec3( 0.3, 0.59, 0.11);\r\n 
	float lum = dot(DF.rgb, weights);\r\n 
	\r\n vec3 col = lum * u_movieColor;\r\n 
	vec4 Complete = vec4(col, 1.0);\r\n 
	\r\n Complete *= dirt;\r\n 
	Complete *= vignette;\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	float u_speedX;\r\nuniform 
	float u_speedY;\r\nuniform 
	float u_time;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio);\r\n 
	v_uv0Mov = (in_TextureCoord + vec2(u_speedX,u_speedY) * u_time) * vec2(1.0, u_vRatio);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\nuniform 
	sampler2D sampler1;\r\n\r\nuniform 
	vec3 u_movieColor;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	vec4 dirt = texture2D( sampler0, v_uv0Mov );\r\n 
	vec4 vignette = texture2D( sampler1, v_uv0Ratio );\r\n 
	\r\n vec3 weights = vec3( 0.95, 0.95, 0.95); 
	//vec3( 0.3, 0.59, 0.11);\r\n 
	float lum = dot(DF.rgb, weights);\r\n 
	\r\n vec3 col = lum * u_movieColor;\r\n 
	vec4 Complete = vec4(col, 1.0);\r\n 
	\r\n Complete *= dirt;\r\n 
	Complete *= vignette;\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	shader_outliner precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\n\r\nuniform 
	float u_threshold;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 blur = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 8;\r\n\r\n 
	for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_threshold;\r\n 
	highp float shift_y = sin(angle) * u_threshold;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / float(SAMPLES);\r\n 
	}\r\n \r\n vec4 DF = texture2D(gm_BaseTexture, v_uv0);\r\n 
	\r\n vec4 outlineMask = DF - blur;\r\n 
	outlineMask *= 2.0;\r\n 
	\r\n float outLine = 1.0 - (dot(outlineMask.rgb, vec3(0.333)));\r\n 
	outLine = 1.0 - pow(outLine, 3.0);\r\n 
	\r\n vec4 Complete = vec4(vec3(outLine), 1.0);\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\n\r\nuniform 
	float u_threshold;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float pi = 3.14159265359;\r\n 
	float circle = 2.0 * pi;\r\n 
	\r\n vec4 blur = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 8;\r\n\r\n 
	for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	highp float angle = (circle / float(SAMPLES)) * float(i);\r\n 
	\r\n highp float shift_x = cos(angle) * u_threshold;\r\n 
	highp float shift_y = sin(angle) * u_threshold;\r\n 
	highp vec2 shiftUV = v_uv0 + vec2(shift_x, shift_y);\r\n 
	\r\n blur += texture2D(gm_BaseTexture, shiftUV) / float(SAMPLES);\r\n 
	}\r\n \r\n vec4 DF = texture2D(gm_BaseTexture, v_uv0);\r\n 
	\r\n vec4 outlineMask = DF - blur;\r\n 
	outlineMask *= 2.0;\r\n 
	\r\n float outLine = 1.0 - (dot(outlineMask.rgb, vec3(0.333)));\r\n 
	outLine = 1.0 - pow(outLine, 3.0);\r\n 
	\r\n vec4 Complete = vec4(vec3(outLine), 1.0);\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	shader_paperBurn precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nuniform sampler2D sampler0;\r\nuniform 
	sampler2D sampler1;\r\n\r\nuniform 
	float u_scale;\r\nuniform 
	float u_speed;\r\nuniform 
	float u_time;\r\nuniform 
	vec3 u_color1;\r\nuniform 
	vec3 u_color2;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n vec4 DF = texture2D( gm_BaseTexture, v_uv0);\r\n 
	vec4 PP = texture2D( sampler0, v_uv0Ratio );\r\n 
	vec4 MK = texture2D( sampler1, v_uv0Ratio );\r\n 
	\r\n float tt = abs(sin(u_time * u_speed));\r\n 
	\r\n float rng_min = max(tt - u_scale * 0.5, 0.0);\r\n 
	float rng_max = min(tt + u_scale * 0.5, 1.0);\r\n 
	\r\n float edg_min = max(tt - u_scale, 0.0);\r\n 
	float edg_max = min(tt + u_scale, 1.0);\r\n 
	\r\n float mixMask = smoothstep(rng_min, rng_max, MK.r);\r\n 
	float edgeMask = smoothstep(edg_min, edg_max, MK.r);\r\n 
	edgeMask = min(edgeMask * (1.0 - mixMask) * 5.0 , 1.0);\r\n 
	\r\n vec3 burnCol = mix(u_color2,u_color1,mixMask);\r\n 
	\r\n vec4 result = mix(DF, PP, mixMask);\r\n 
	result = mix(result, vec4(burnCol,1.0), edgeMask);\r\n 
	\r\n gl_FragColor = vec4(result.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nuniform sampler2D sampler0;\r\nuniform 
	sampler2D sampler1;\r\n\r\nuniform 
	float u_scale;\r\nuniform 
	float u_speed;\r\nuniform 
	float u_time;\r\nuniform 
	vec3 u_color1;\r\nuniform 
	vec3 u_color2;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n vec4 DF = texture2D( gm_BaseTexture, v_uv0);\r\n 
	vec4 PP = texture2D( sampler0, v_uv0Ratio );\r\n 
	vec4 MK = texture2D( sampler1, v_uv0Ratio );\r\n 
	\r\n float tt = abs(sin(u_time * u_speed));\r\n 
	\r\n float rng_min = max(tt - u_scale * 0.5, 0.0);\r\n 
	float rng_max = min(tt + u_scale * 0.5, 1.0);\r\n 
	\r\n float edg_min = max(tt - u_scale, 0.0);\r\n 
	float edg_max = min(tt + u_scale, 1.0);\r\n 
	\r\n float mixMask = smoothstep(rng_min, rng_max, MK.r);\r\n 
	float edgeMask = smoothstep(edg_min, edg_max, MK.r);\r\n 
	edgeMask = min(edgeMask * (1.0 - mixMask) * 5.0 , 1.0);\r\n 
	\r\n vec3 burnCol = mix(u_color2,u_color1,mixMask);\r\n 
	\r\n vec4 result = mix(DF, PP, mixMask);\r\n 
	result = mix(result, vec4(burnCol,1.0), edgeMask);\r\n 
	\r\n gl_FragColor = vec4(result.rgb, 1.0);\r\n}\r\n\r\n 
	shader_radialBlur shader_rain #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	vec2 u_speed1;\r\nuniform 
	vec2 u_speed2;\r\nuniform 
	vec2 u_scale1;\r\nuniform 
	vec2 u_scale2;\r\nuniform 
	float u_time;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv1Mov;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord;\r\n 
	\r\n v_uv0Mov = (in_TextureCoord + u_speed1 * u_time) * vec2(1.0, u_vRatio);\r\n 
	v_uv0Mov *= u_scale1;\r\n 
	\r\n v_uv1Mov = (in_TextureCoord + u_speed2 * u_time) * vec2(1.0, u_vRatio);\r\n 
	v_uv1Mov *= u_scale2;\r\n}\r\n\r\n 
	precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv1Mov;\r\n\r\nuniform 
	sampler2D sampler0;\r\nuniform 
	sampler2D sampler1;\r\n\r\nuniform 
	vec3 u_color;\r\nuniform 
	float u_rain1alpha;\r\nuniform 
	float u_rain2alpha;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	\r\n vec4 rain1 = texture2D( sampler0, v_uv0Mov );\r\n 
	vec4 rain2 = texture2D( sampler0, v_uv1Mov );\r\n 
	\r\n vec3 Complete = vec3(0.0, 0.0, 0.0);\r\n 
	Complete = mix(DF.rgb, u_color, rain1.r*u_rain1alpha);\r\n 
	Complete = mix(Complete.rgb, u_color, rain2.r*u_rain2alpha);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\nuniform 
	vec2 u_speed1;\r\nuniform 
	vec2 u_speed2;\r\nuniform 
	vec2 u_scale1;\r\nuniform 
	vec2 u_scale2;\r\nuniform 
	float u_time;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv1Mov;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord;\r\n 
	\r\n v_uv0Mov = (in_TextureCoord + u_speed1 * u_time) * vec2(1.0, u_vRatio);\r\n 
	v_uv0Mov *= u_scale1;\r\n 
	\r\n v_uv1Mov = (in_TextureCoord + u_speed2 * u_time) * vec2(1.0, u_vRatio);\r\n 
	v_uv1Mov *= u_scale2;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Mov;\r\nvarying 
	vec2 v_uv1Mov;\r\n\r\nuniform 
	sampler2D sampler0;\r\nuniform 
	sampler2D sampler1;\r\n\r\nuniform 
	vec3 u_color;\r\nuniform 
	float u_rain1alpha;\r\nuniform 
	float u_rain2alpha;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	\r\n vec4 rain1 = texture2D( sampler0, v_uv0Mov );\r\n 
	vec4 rain2 = texture2D( sampler0, v_uv1Mov );\r\n 
	\r\n vec3 Complete = vec3(0.0, 0.0, 0.0);\r\n 
	Complete = mix(DF.rgb, u_color, rain1.r*u_rain1alpha);\r\n 
	Complete = mix(Complete.rgb, u_color, rain2.r*u_rain2alpha);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	shader_scanner precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nuniform sampler2D sampler0;\r\n\r\nuniform 
	float u_scale;\r\nuniform 
	float u_speed;\r\nuniform 
	float u_time;\r\nuniform 
	vec3 u_color1;\r\nuniform 
	vec3 u_color2;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n vec4 DF = texture2D( gm_BaseTexture, v_uv0);\r\n 
	vec4 SC = texture2D( sampler0, v_uv0Ratio );\r\n 
	\r\n vec4 result = vec4(DF.rgb * SC.rgb * u_color1, 1.0);\r\n 
	\r\n float tt = abs(sin(u_time * u_speed));\r\n 
	\r\n float lum = dot(result.rgb, vec3( 0.2126, 0.7152, 0.0722));\r\n 
	\r\n float rng_min = max(tt - u_scale, 0.0);\r\n 
	float rng_max = min(tt + u_scale, 1.0);\r\n 
	\r\n float scanR1 = smoothstep(rng_min, tt, v_uv0.x);\r\n 
	float scanR2 = smoothstep(tt, rng_max, v_uv0.x);\r\n 
	\r\n float scanMix = abs(scanR1 * (1.0 - scanR2));\r\n 
	\r\n scanMix = scanMix * (pow(1.0 - lum, 5.0));\r\n 
	\r\n vec3 scanCol = scanMix * u_color2;\r\n 
	\r\n vec4 Complete = result + vec4(scanCol, 1.0);\r\n 
	Complete *= 1.5; 
	//overbright\r\n \r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nuniform sampler2D sampler0;\r\n\r\nuniform 
	float u_scale;\r\nuniform 
	float u_speed;\r\nuniform 
	float u_time;\r\nuniform 
	vec3 u_color1;\r\nuniform 
	vec3 u_color2;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n vec4 DF = texture2D( gm_BaseTexture, v_uv0);\r\n 
	vec4 SC = texture2D( sampler0, v_uv0Ratio );\r\n 
	\r\n vec4 result = vec4(DF.rgb * SC.rgb * u_color1, 1.0);\r\n 
	\r\n float tt = abs(sin(u_time * u_speed));\r\n 
	\r\n float lum = dot(result.rgb, vec3( 0.2126, 0.7152, 0.0722));\r\n 
	\r\n float rng_min = max(tt - u_scale, 0.0);\r\n 
	float rng_max = min(tt + u_scale, 1.0);\r\n 
	\r\n float scanR1 = smoothstep(rng_min, tt, v_uv0.x);\r\n 
	float scanR2 = smoothstep(tt, rng_max, v_uv0.x);\r\n 
	\r\n float scanMix = abs(scanR1 * (1.0 - scanR2));\r\n 
	\r\n scanMix = scanMix * (pow(1.0 - lum, 5.0));\r\n 
	\r\n vec3 scanCol = scanMix * u_color2;\r\n 
	\r\n vec4 Complete = result + vec4(scanCol, 1.0);\r\n 
	Complete *= 1.5; 
	//overbright\r\n \r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	shader_sceneFringe precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_threshold;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float VG = abs(v_uv0.x * 2.0 - 1.0);\r\n 
	\r\n vec2 uv_R = v_uv0 + (vec2(u_threshold, 0.0) * VG);\r\n 
	vec2 uv_GB = v_uv0 - (vec2(u_threshold, 0.0) * VG);\r\n 
	\r\n float DF_r = texture2D( gm_BaseTexture, uv_R ).r;\r\n 
	vec2 DF_gb = texture2D( gm_BaseTexture, uv_GB ).gb;\r\n 
	\r\n vec4 Complete = vec4(0.0,0.0,0.0,1.0);\r\n 
	Complete.r = DF_r;\r\n 
	Complete.gb = DF_gb;\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_threshold;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float VG = abs(v_uv0.x * 2.0 - 1.0);\r\n 
	\r\n vec2 uv_R = v_uv0 + (vec2(u_threshold, 0.0) * VG);\r\n 
	vec2 uv_GB = v_uv0 - (vec2(u_threshold, 0.0) * VG);\r\n 
	\r\n float DF_r = texture2D( gm_BaseTexture, uv_R ).r;\r\n 
	vec2 DF_gb = texture2D( gm_BaseTexture, uv_GB ).gb;\r\n 
	\r\n vec4 Complete = vec4(0.0,0.0,0.0,1.0);\r\n 
	Complete.r = DF_r;\r\n 
	Complete.gb = DF_gb;\r\n 
	\r\n gl_FragColor = Complete;\r\n}\r\n\r\n 
	shader_thermalVision precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	\r\n vec3 weights = vec3( 0.3, 0.59, 0.11);\r\n 
	float lum = dot(DF.rgb, weights);\r\n 
	lum = clamp(lum, 0.0, 1.0);\r\n 
	\r\n vec2 rUV = vec2(lum, 0.5);\r\n 
	\r\n vec4 Complete = texture2D( sampler0, rUV );\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	\r\n vec3 weights = vec3( 0.3, 0.59, 0.11);\r\n 
	float lum = dot(DF.rgb, weights);\r\n 
	lum = clamp(lum, 0.0, 1.0);\r\n 
	\r\n vec2 rUV = vec2(lum, 0.5);\r\n 
	\r\n vec4 Complete = texture2D( sampler0, rUV );\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	shader_vignette #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio);\r\n}\r\n\r\n 
	precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	vec4 VG = texture2D( sampler0, v_uv0Ratio );\r\n 
	\r\n gl_FragColor = DF * VG;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord; 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\n\r\nuniform 
	sampler2D sampler0;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 DF = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	vec4 VG = texture2D( sampler0, v_uv0Ratio );\r\n 
	\r\n gl_FragColor = DF * VG;\r\n}\r\n\r\n 
	shader_volumeLight precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_amplitude;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float piNum = 3.14159265359;\r\n 
	float circle = 2.0 * piNum;\r\n 
	\r\n vec4 lightShaft = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 16;\r\n 
	\r\n float stp = (1.0 / float(SAMPLES));\r\n 
	\r\n vec2 unit = vec2(1.0,1.0);\r\n 
	\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	float amp = (u_amplitude / float(SAMPLES)) * float(i);\r\n 
	\r\n float shift_x = amp;\r\n 
	float shift_y = amp;\r\n 
	\r\n vec2 shiftUV = v_uv0 + (vec2(shift_x, shift_y) * ((1.0 - v_uv0) * 2.0 -1.0));\r\n 
	\r\n vec4 DF = vec4(1.0) - texture2D(gm_BaseTexture, shiftUV);\r\n 
	DF = smoothstep(0.8, 1.0, DF) * (1.0 - (float(i) / float(SAMPLES))); 
	\r\n\r\n lightShaft += DF / float(SAMPLES); 
	\r\n }\r\n \r\n vec4 Complete = texture2D(gm_BaseTexture, v_uv0) + (lightShaft * 2.0);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_uv0;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nuniform 
	float u_amplitude;\r\n\r\nvoid 
	main()\r\n{\r\n 
	float piNum = 3.14159265359;\r\n 
	float circle = 2.0 * piNum;\r\n 
	\r\n vec4 lightShaft = vec4(0.0,0.0,0.0,0.0);\r\n 
	\r\n int SAMPLES = 16;\r\n 
	\r\n float stp = (1.0 / float(SAMPLES));\r\n 
	\r\n vec2 unit = vec2(1.0,1.0);\r\n 
	\r\n for (int i = 0; 
	i < SAMPLES; 
	i++)\r\n {\r\n 
	float amp = (u_amplitude / float(SAMPLES)) * float(i);\r\n 
	\r\n float shift_x = amp;\r\n 
	float shift_y = amp;\r\n 
	\r\n vec2 shiftUV = v_uv0 + (vec2(shift_x, shift_y) * ((1.0 - v_uv0) * 2.0 -1.0));\r\n 
	\r\n vec4 DF = vec4(1.0) - texture2D(gm_BaseTexture, shiftUV);\r\n 
	DF = smoothstep(0.8, 1.0, DF) * (1.0 - (float(i) / float(SAMPLES))); 
	\r\n\r\n lightShaft += DF / float(SAMPLES); 
	\r\n }\r\n \r\n vec4 Complete = texture2D(gm_BaseTexture, v_uv0) + (lightShaft * 2.0);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	shader_waterReflection #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0_flip;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord;\r\n 
	\r\n v_uv0_flip = in_TextureCoord;\r\n 
	v_uv0_flip.y = 1.0 - in_TextureCoord.y;\r\n 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio); 
	\r\n}\r\n\r\n precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nuniform sampler2D sampler0;\r\n\r\nuniform 
	float u_amplitude;\r\nuniform 
	float u_distAmount;\r\nuniform 
	vec3 u_waterColor;\r\nuniform 
	float u_waterLevel;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0_flip;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n float waterLevel = u_waterLevel + u_amplitude;\r\n 
	vec3 waterColor = u_waterColor;\r\n 
	float waterMask = smoothstep(waterLevel, 1.0, v_uv0.y);\r\n 
	\r\n vec4 NM = texture2D( sampler0, v_uv0Ratio ) * 2.0 - 1.0;\r\n 
	\r\n vec4 previous = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	\r\n vec2 uvs = v_uv0_flip + vec2(0.0, (waterLevel - (1.0 - waterLevel))) + (u_distAmount * NM.rg);\r\n 
	\r\n vec4 RF = texture2D( gm_BaseTexture, uvs);\r\n 
	RF.rgb = mix(RF.rgb, waterColor, waterMask);\r\n 
	RF.rgb *= waterColor;\r\n 
	\r\n float mixVal;\r\n 
	\r\n if (v_uv0.y < waterLevel)\r\n {\r\n 
	mixVal = 1.0;\r\n 
	}else{\r\n 
	mixVal = 0.0;\r\n 
	}\r\n \r\n vec4 Complete = mix(RF,previous,mixVal);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\n\r\nuniform 
	float u_vRatio;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0_flip;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_uv0 = in_TextureCoord;\r\n 
	\r\n v_uv0_flip = in_TextureCoord;\r\n 
	v_uv0_flip.y = 1.0 - in_TextureCoord.y;\r\n 
	\r\n v_uv0Ratio = in_TextureCoord * vec2(1.0, u_vRatio); 
	\r\n}\r\n\r\n #version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nuniform sampler2D sampler0;\r\n\r\nuniform 
	float u_amplitude;\r\nuniform 
	float u_distAmount;\r\nuniform 
	vec3 u_waterColor;\r\nuniform 
	float u_waterLevel;\r\n\r\nvarying 
	vec2 v_uv0;\r\nvarying 
	vec2 v_uv0_flip;\r\nvarying 
	vec2 v_uv0Ratio;\r\n\r\nvoid 
	main()\r\n{ 
	\r\n float waterLevel = u_waterLevel + u_amplitude;\r\n 
	vec3 waterColor = u_waterColor;\r\n 
	float waterMask = smoothstep(waterLevel, 1.0, v_uv0.y);\r\n 
	\r\n vec4 NM = texture2D( sampler0, v_uv0Ratio ) * 2.0 - 1.0;\r\n 
	\r\n vec4 previous = texture2D( gm_BaseTexture, v_uv0 );\r\n 
	\r\n vec2 uvs = v_uv0_flip + vec2(0.0, (waterLevel - (1.0 - waterLevel))) + (u_distAmount * NM.rg);\r\n 
	\r\n vec4 RF = texture2D( gm_BaseTexture, uvs);\r\n 
	RF.rgb = mix(RF.rgb, waterColor, waterMask);\r\n 
	RF.rgb *= waterColor;\r\n 
	\r\n float mixVal;\r\n 
	\r\n if (v_uv0.y < waterLevel)\r\n {\r\n 
	mixVal = 1.0;\r\n 
	}else{\r\n 
	mixVal = 0.0;\r\n 
	}\r\n \r\n vec4 Complete = mix(RF,previous,mixVal);\r\n 
	\r\n gl_FragColor = vec4(Complete.rgb, 1.0);\r\n}\r\n\r\n 
	gles_Radial #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\n//\r\n// Simple passthrough vertex shader\r\n//\r\nattribute vec3 in_Position; 
	// (x,y,z)\r\nattribute vec4 in_Colour; 
	// (r,g,b,a)\r\nattribute vec2 in_TextureCoord; 
	// (u,v)\r\n//attribute vec3 in_Normal; 
	// (x,y,z) unused in this shader. \r\n\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_vColour = in_Colour;\r\n 
	v_vTexcoord = in_TextureCoord;\r\n}\r\n\r\n 
	precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nuniform vec2 Position;\r\nuniform 
	vec2 Resolution;\r\nuniform 
	vec2 Viewport;\r\nuniform 
	vec2 mouse;\r\nuniform 
	float time;\r\nuniform 
	sampler2D tex0;\r\nvarying 
	vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nvec3 
	deform( in vec2 p )\r\n{\r\n 
	vec2 uv;\r\n 
	vec2 q = vec2( sin(1.1*time+p.x),sin(1.2*time+p.y) );\r\n 
	float a = atan(q.y,q.x);\r\n 
	float r = sqrt(dot(q,q));\r\n 
	uv.x = sin(0.0+1.0*mouse.x)+p.x*sqrt(r*r+1.0);\r\n 
	uv.y = sin(0.6+1.1*mouse.y)+p.y*sqrt(r*r+1.0);\r\n 
	return texture2D(tex0,uv*0.5).xyz;\r\n}\r\nvoid 
	main(void) {\r\n 
	vec2 p = -1.0 + 2.0 * (Position+v_vTexcoord*Viewport) / Resolution; 
	// was +gl_FragCoord.xy\r\n vec2 s = p;\r\n 
	vec3 total = vec3(0.0);\r\n 
	vec2 d = (vec2(0.0,0.0)-p)/40.0;\r\n 
	float w = 1.0;\r\n 
	for( int i=0; 
	i<40; 
	i++ ) {\r\n 
	vec3 res = deform(s);\r\n 
	res = smoothstep(0.1,1.0,res*res);\r\n 
	total += w*res;\r\n 
	w *= 0.99;\r\n 
	s += d;\r\n 
	}\r\n total /= 40.0;\r\n 
	float r = 1.5/(1.0+dot(p,p));\r\n 
	gl_FragColor = vec4( vec3(total*r)*v_vColour.rgb,1.0);\r\n}\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\n//\r\n// Simple passthrough vertex shader\r\n//\r\nattribute vec3 in_Position; 
	// (x,y,z)\r\nattribute vec4 in_Colour; 
	// (r,g,b,a)\r\nattribute vec2 in_TextureCoord; 
	// (u,v)\r\n//attribute vec3 in_Normal; 
	// (x,y,z) unused in this shader. \r\n\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_vColour = in_Colour;\r\n 
	v_vTexcoord = in_TextureCoord;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nuniform vec2 Position;\r\nuniform 
	vec2 Resolution;\r\nuniform 
	vec2 Viewport;\r\nuniform 
	vec2 mouse;\r\nuniform 
	float time;\r\nuniform 
	sampler2D tex0;\r\nvarying 
	vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nvec3 
	deform( in vec2 p )\r\n{\r\n 
	vec2 uv;\r\n 
	vec2 q = vec2( sin(1.1*time+p.x),sin(1.2*time+p.y) );\r\n 
	float a = atan(q.y,q.x);\r\n 
	float r = sqrt(dot(q,q));\r\n 
	uv.x = sin(0.0+1.0*mouse.x)+p.x*sqrt(r*r+1.0);\r\n 
	uv.y = sin(0.6+1.1*mouse.y)+p.y*sqrt(r*r+1.0);\r\n 
	return texture2D(tex0,uv*0.5).xyz;\r\n}\r\nvoid 
	main(void) {\r\n 
	vec2 p = -1.0 + 2.0 * (Position+v_vTexcoord*Viewport) / Resolution; 
	// was +gl_FragCoord.xy\r\n vec2 s = p;\r\n 
	vec3 total = vec3(0.0);\r\n 
	vec2 d = (vec2(0.0,0.0)-p)/40.0;\r\n 
	float w = 1.0;\r\n 
	for( int i=0; 
	i<40; 
	i++ ) {\r\n 
	vec3 res = deform(s);\r\n 
	res = smoothstep(0.1,1.0,res*res);\r\n 
	total += w*res;\r\n 
	w *= 0.99;\r\n 
	s += d;\r\n 
	}\r\n total /= 40.0;\r\n 
	float r = 1.5/(1.0+dot(p,p));\r\n 
	gl_FragColor = vec4( vec3(total*r)*v_vColour.rgb,1.0);\r\n}\r\n 
	gles_Ripple precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nuniform vec2 resolution; 
	// Screen resolution\r\nuniform float time; 
	// time in seconds\r\nuniform float Scale; 
	// scale (default: 12.0)\r\nuniform sampler2D tex0; 
	// thing to ripple\r\nvarying vec2 v_vTexcoord;\r\nvoid 
	main(void)\r\n{\r\n 
	vec2 p = -1.0 + 2.0 * v_vTexcoord;\r\n 
	float len = length(p);\r\n 
	vec2 uv = v_vTexcoord + (p/len)*cos(len*Scale-time*4.0)*0.03;\r\n 
	vec3 col = texture2D(tex0,uv).xyz;\r\n 
	gl_FragColor = vec4(col,1.0);\r\n}\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nuniform vec2 resolution; 
	// Screen resolution\r\nuniform float time; 
	// time in seconds\r\nuniform float Scale; 
	// scale (default: 12.0)\r\nuniform sampler2D tex0; 
	// thing to ripple\r\nvarying vec2 v_vTexcoord;\r\nvoid 
	main(void)\r\n{\r\n 
	vec2 p = -1.0 + 2.0 * v_vTexcoord;\r\n 
	float len = length(p);\r\n 
	vec2 uv = v_vTexcoord + (p/len)*cos(len*Scale-time*4.0)*0.03;\r\n 
	vec3 col = texture2D(tex0,uv).xyz;\r\n 
	gl_FragColor = vec4(col,1.0);\r\n}\r\n 
	shd_pal_swapper #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\nattribute vec3 in_Position; 
	// (x,y,z)\r\nattribute vec4 in_Colour; 
	// (r,g,b,a)\r\nattribute vec2 in_TextureCoord; 
	// (u,v)\r\n\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_vColour = in_Colour;\r\n 
	v_vTexcoord = in_TextureCoord;\r\n}\r\n\r\n 
	precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nuniform 
	sampler2D palette_texture;\r\nuniform 
	vec2 texel_size;\r\nuniform 
	vec4 palette_UVs;\r\nuniform 
	float palette_index;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 source = texture2D( gm_BaseTexture, v_vTexcoord );\r\n 
	\r\n DoAlphaTest( source );\r\n 
	\r\n for(float i = palette_UVs.y; 
	i < palette_UVs.w; 
	i+=texel_size.y )\r\n {\r\n 
	if (distance(source, texture2D(palette_texture, vec2(palette_UVs.x, i))) <= 0.004)\r\n {\r\n 
	float palette_V = palette_UVs.x + texel_size.x * palette_index;\r\n 
	source = texture2D(palette_texture, vec2(palette_V, i));\r\n 
	break;\r\n 
	}\r\n }\r\n\r\n gl_FragColor = source * v_vColour;\r\n}\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\nattribute vec3 in_Position; 
	// (x,y,z)\r\nattribute vec4 in_Colour; 
	// (r,g,b,a)\r\nattribute vec2 in_TextureCoord; 
	// (u,v)\r\n\r\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);\r\n 
	gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;\r\n 
	\r\n v_vColour = in_Colour;\r\n 
	v_vTexcoord = in_TextureCoord;\r\n}\r\n\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nuniform 
	sampler2D palette_texture;\r\nuniform 
	vec2 texel_size;\r\nuniform 
	vec4 palette_UVs;\r\nuniform 
	float palette_index;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 source = texture2D( gm_BaseTexture, v_vTexcoord );\r\n 
	\r\n DoAlphaTest( source );\r\n 
	\r\n for(float i = palette_UVs.y; 
	i < palette_UVs.w; 
	i+=texel_size.y )\r\n {\r\n 
	if (distance(source, texture2D(palette_texture, vec2(palette_UVs.x, i))) <= 0.004)\r\n {\r\n 
	float palette_V = palette_UVs.x + texel_size.x * palette_index;\r\n 
	source = texture2D(palette_texture, vec2(palette_V, i));\r\n 
	break;\r\n 
	}\r\n }\r\n\r\n gl_FragColor = source * v_vColour;\r\n}\r\n 
	sh_saturation precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\nuniform 
	float Position;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 Colour = texture2D( gm_BaseTexture, v_vTexcoord ); 
	// get colour of pixel\r\n float Max = max(Colour.r, max(Colour.g, Colour.b)); 
	// get max channel of pixel\r\n float Min = min(Colour.r, min(Colour.g, Colour.b)); 
	// get min channel of pixel\r\n float Sat = 1.0-Min/Max; 
	// get current saturation of pixel\r\n // set saturation to pixel that depends on Position uniform\r\n Colour.r = clamp(Max-(Max-Colour.r)/Sat*(Sat+Position), 0.0, Max); 
	// for red channel\r\n Colour.g = clamp(Max-(Max-Colour.g)/Sat*(Sat+Position), 0.0, Max); 
	// for green channel\r\n Colour.b = clamp(Max-(Max-Colour.b)/Sat*(Sat+Position), 0.0, Max); 
	// for blue channel\r\n gl_FragColor = v_vColour * Colour;\r\n}\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\nuniform 
	float Position;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 Colour = texture2D( gm_BaseTexture, v_vTexcoord ); 
	// get colour of pixel\r\n float Max = max(Colour.r, max(Colour.g, Colour.b)); 
	// get max channel of pixel\r\n float Min = min(Colour.r, min(Colour.g, Colour.b)); 
	// get min channel of pixel\r\n float Sat = 1.0-Min/Max; 
	// get current saturation of pixel\r\n // set saturation to pixel that depends on Position uniform\r\n Colour.r = clamp(Max-(Max-Colour.r)/Sat*(Sat+Position), 0.0, Max); 
	// for red channel\r\n Colour.g = clamp(Max-(Max-Colour.g)/Sat*(Sat+Position), 0.0, Max); 
	// for green channel\r\n Colour.b = clamp(Max-(Max-Colour.b)/Sat*(Sat+Position), 0.0, Max); 
	// for blue channel\r\n gl_FragColor = v_vColour * Colour;\r\n}\r\n 
	sh_flag #define LOWPREC lowp\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSLES_ 1\n// This vertex shader lerps between two states (folded and unfolded) where wind affects animation speed, blending and mirroring of the states. Then some adjustments are done when in between the states and vertex lighting is set.\r\n\r\nattribute vec2 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\nvarying 
	vec2 v_vTexcoord;\r\nvarying 
	float lighting;\r\nuniform 
	float time;\r\nuniform 
	vec4 precalculated; 
	//x: Curve amplitude in the upper left corner when folded. y: Inner edge offset when unfolded. z: Sign for mirroring. w: Blend amount from folded to unfolded.\r\nuniform vec4 precalculated_1; 
	//x: Blend amount for in between the states. y: Adjusted blend amount for in between the states. z: sin(time). w: time * 0.2.\r\nuniform float precalculated_2; 
	//x: Blend amount from folded to unfolded reduced.\r\nconst float PI = 3.141592, TAU = PI * 2.0, TAU_TIMES_TWO = TAU * 2.0;\r\n\r\nfloat 
	custom_wave(float x)\r\n{\r\n 
	return sin(x) * sin(0.5 * x) * (1.5 + sin(0.05 * x) * 0.5);\r\n}\r\n\r\nvoid 
	main()\r\n{ 
	\r\n v_vTexcoord = in_TextureCoord;\r\n 
	\r\n gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * vec4(\r\n mix(\r\n vec2(\r\n // First argument inside the mix function makes the upper left corner less spiky. Second argument shifts the outer vertices and adds waves to the horizontal edges. Last addend adds waves to the vertical edges.\r\n mix(precalculated.x * sin(in_Position.y * PI) * (3.0 - in_Position.y), sin(in_Position.y * TAU) * 0.15 + 0.01, in_Position.x) + sin(in_Position.x * 10.0) * 0.01 * (1.0 - sin(in_Position.y * PI)),\r\n // Moves outer vertices down.\r\n in_Position.y + in_Position.x\r\n ),\r\n vec2(\r\n // The mix function adds an offset to the inner edge and a wave to the outer edge which is multiplied preventing the corners from being affected. The last factor enables mirroring.\r\n (in_Position.x + sin(in_Position.y * PI) * 0.03 * mix(precalculated.y, custom_wave(time + in_Position.y * 2.0), in_Position.x)) * precalculated.z,\r\n // First addend inside the parantheses is responsible for the vertical waves, second addend makes the distance between the outer corners vary. It's all multiplied with x to prevent the inner corners from moving.\r\n in_Position.y + in_Position.x * 0.1 * (custom_wave(time + in_Position.x * 3.0) + precalculated_1.z * in_Position.y)\r\n ),\r\n precalculated.w\r\n ) +\r\n // This offset is at its highest when in between the two states. The inner edge is shifted and gets more waves, and the outer edge's waves get more intense. y is shifted to make the lerping look rounder.\r\n vec2(\r\n precalculated_1.x * mix(sin(in_Position.y * PI) * 0.03 * (1.0 + sin(time + in_Position.y * 2.0)), 0.1 * custom_wave(time + in_Position.y * 5.0), in_Position.x),\r\n precalculated_1.y * in_Position.x\r\n ),\r\n 0.0, 1.0);\r\n 
	\r\n // Adds faint gradients to the flag in the form of sine patterns. Second addend adds vertical gradients which matches the folded pattern. Third addend adds horizontal gradients when unfolded.\r\n lighting = 0.93 + sin(in_Position.y * TAU_TIMES_TWO) * 0.07 + sin(precalculated_1.w + in_Position.y) * sin(time + in_Position.x * 10.0) * precalculated_2;\r\n}\r\n 
	precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_vTexcoord;\r\nvarying 
	float lighting;\r\n\r\nuniform 
	vec4 sprite_uvs;\r\n\r\nvoid 
	main()\r\n{\r\n 
	gl_FragColor = texture2D(gm_BaseTexture, sprite_uvs.xy + v_vTexcoord * sprite_uvs.zw);\r\n 
	gl_FragColor.rgb *= lighting;\r\n}\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n#define MATRIX_VIEW 0\r\n#define MATRIX_PROJECTION 1\r\n#define MATRIX_WORLD 2\r\n#define MATRIX_WORLD_VIEW 3\r\n#define MATRIX_WORLD_VIEW_PROJECTION 4\r\n#define MATRICES_MAX 5\r\n\r\nuniform mat4 gm_Matrices[MATRICES_MAX]; 
	\r\n\r\nuniform bool gm_LightingEnabled;\r\nuniform 
	bool gm_VS_FogEnabled;\r\nuniform 
	float gm_FogStart;\r\nuniform 
	float gm_RcpFogRange;\r\n\r\n#define 
	MAX_VS_LIGHTS 8\r\n#define MIRROR_WIN32_LIGHTING_EQUATION\r\n\r\n\r\n//#define MAX_VS_LIGHTS 8\r\nuniform vec4 gm_AmbientColour; 
	// rgb=colour, a=1\r\nuniform vec4 gm_Lights_Direction[MAX_VS_LIGHTS]; 
	// normalised direction\r\nuniform vec4 gm_Lights_PosRange[MAX_VS_LIGHTS]; 
	// X,Y,Z position, W range\r\nuniform vec4 gm_Lights_Colour[MAX_VS_LIGHTS]; 
	// rgb=colour, a=1\r\n\r\nfloat CalcFogFactor(vec4 pos)\r\n{\r\n 
	if (gm_VS_FogEnabled)\r\n {\r\n 
	vec4 viewpos = gm_Matrices[MATRIX_WORLD_VIEW] * pos;\r\n 
	float fogfactor = ((viewpos.z - gm_FogStart) * gm_RcpFogRange);\r\n 
	return fogfactor;\r\n 
	}\r\n else\r\n {\r\n 
	return 0.0;\r\n 
	}\r\n}\r\n\r\nvec4 DoDirLight(vec3 ws_normal, vec4 dir, vec4 diffusecol)\r\n{\r\n 
	float dotresult = dot(ws_normal, dir.xyz);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * diffusecol;\r\n}\r\n\r\nvec4 
	DoPointLight(vec3 ws_pos, vec3 ws_normal, vec4 posrange, vec4 diffusecol)\r\n{\r\n 
	vec3 diffvec = ws_pos - posrange.xyz;\r\n 
	float veclen = length(diffvec);\r\n 
	diffvec /= veclen; 
	// normalise\r\n#ifdef MIRROR_WIN32_LIGHTING_EQUATION\r\n // This is based on the Win32 D3D and OpenGL falloff model, where:\r\n // Attenuation = 1.0f / (factor0 + (d * factor1) + (d*d * factor2))\r\n // For some reason, factor0 is set to 0.0f while factor1 is set to 1.0f/lightrange (on both D3D and OpenGL)\r\n // This'll result in no visible falloff as 1.0f / (d / lightrange) will always be larger than 1.0f (if the vertex is within range)\r\n float atten = 1.0 / (veclen / posrange.w);\r\n 
	if (veclen > posrange.w)\r\n {\r\n 
	atten = 0.0;\r\n 
	}\r\n#else\r\n float atten = clamp( (1.0 - (veclen / posrange.w)), 0.0, 1.0); 
	// storing 1.0f/range instead would save a rcp\r\n#endif\r\n float dotresult = dot(ws_normal, diffvec);\r\n 
	dotresult = max(0.0, dotresult);\r\n\r\n 
	return dotresult * atten * diffusecol;\r\n}\r\n\r\nvec4 
	DoLighting(vec4 vertexcolour, vec4 objectspacepos, vec3 objectspacenormal)\r\n{\r\n 
	if (gm_LightingEnabled)\r\n {\r\n 
	// Normally we'd have the light positions\\\\directions back-transformed from world to object space\r\n // But to keep things simple for the moment we'll just transform the normal to world space\r\n vec4 objectspacenormal4 = vec4(objectspacenormal, 0.0);\r\n 
	vec3 ws_normal;\r\n 
	ws_normal = (gm_Matrices[MATRIX_WORLD_VIEW] * objectspacenormal4).xyz;\r\n 
	ws_normal = -normalize(ws_normal);\r\n\r\n 
	vec3 ws_pos;\r\n 
	ws_pos = (gm_Matrices[MATRIX_WORLD] * objectspacepos).xyz;\r\n\r\n 
	// Accumulate lighting from different light types\r\n vec4 accumcol = vec4(0.0, 0.0, 0.0, 0.0); 
	\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoDirLight(ws_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n for(int i = 0; 
	i < MAX_VS_LIGHTS; 
	i++)\r\n {\r\n 
	accumcol += DoPointLight(ws_pos, ws_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);\r\n 
	}\r\n\r\n accumcol *= vertexcolour;\r\n 
	accumcol += gm_AmbientColour;\r\n 
	accumcol = min(vec4(1.0, 1.0, 1.0, 1.0), accumcol);\r\n 
	accumcol.a = vertexcolour.a;\r\n 
	return accumcol;\r\n 
	}\r\n else\r\n {\r\n 
	return vertexcolour;\r\n 
	}\r\n}\r\n\r\n#define _YY_GLSL_ 1\n// This vertex shader lerps between two states (folded and unfolded) where wind affects animation speed, blending and mirroring of the states. Then some adjustments are done when in between the states and vertex lighting is set.\r\n\r\nattribute vec2 in_Position;\r\nattribute 
	vec2 in_TextureCoord;\r\nvarying 
	vec2 v_vTexcoord;\r\nvarying 
	float lighting;\r\nuniform 
	float time;\r\nuniform 
	vec4 precalculated; 
	//x: Curve amplitude in the upper left corner when folded. y: Inner edge offset when unfolded. z: Sign for mirroring. w: Blend amount from folded to unfolded.\r\nuniform vec4 precalculated_1; 
	//x: Blend amount for in between the states. y: Adjusted blend amount for in between the states. z: sin(time). w: time * 0.2.\r\nuniform float precalculated_2; 
	//x: Blend amount from folded to unfolded reduced.\r\nconst float PI = 3.141592, TAU = PI * 2.0, TAU_TIMES_TWO = TAU * 2.0;\r\n\r\nfloat 
	custom_wave(float x)\r\n{\r\n 
	return sin(x) * sin(0.5 * x) * (1.5 + sin(0.05 * x) * 0.5);\r\n}\r\n\r\nvoid 
	main()\r\n{ 
	\r\n v_vTexcoord = in_TextureCoord;\r\n 
	\r\n gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * vec4(\r\n mix(\r\n vec2(\r\n // First argument inside the mix function makes the upper left corner less spiky. Second argument shifts the outer vertices and adds waves to the horizontal edges. Last addend adds waves to the vertical edges.\r\n mix(precalculated.x * sin(in_Position.y * PI) * (3.0 - in_Position.y), sin(in_Position.y * TAU) * 0.15 + 0.01, in_Position.x) + sin(in_Position.x * 10.0) * 0.01 * (1.0 - sin(in_Position.y * PI)),\r\n // Moves outer vertices down.\r\n in_Position.y + in_Position.x\r\n ),\r\n vec2(\r\n // The mix function adds an offset to the inner edge and a wave to the outer edge which is multiplied preventing the corners from being affected. The last factor enables mirroring.\r\n (in_Position.x + sin(in_Position.y * PI) * 0.03 * mix(precalculated.y, custom_wave(time + in_Position.y * 2.0), in_Position.x)) * precalculated.z,\r\n // First addend inside the parantheses is responsible for the vertical waves, second addend makes the distance between the outer corners vary. It's all multiplied with x to prevent the inner corners from moving.\r\n in_Position.y + in_Position.x * 0.1 * (custom_wave(time + in_Position.x * 3.0) + precalculated_1.z * in_Position.y)\r\n ),\r\n precalculated.w\r\n ) +\r\n // This offset is at its highest when in between the two states. The inner edge is shifted and gets more waves, and the outer edge's waves get more intense. y is shifted to make the lerping look rounder.\r\n vec2(\r\n precalculated_1.x * mix(sin(in_Position.y * PI) * 0.03 * (1.0 + sin(time + in_Position.y * 2.0)), 0.1 * custom_wave(time + in_Position.y * 5.0), in_Position.x),\r\n precalculated_1.y * in_Position.x\r\n ),\r\n 0.0, 1.0);\r\n 
	\r\n // Adds faint gradients to the flag in the form of sine patterns. Second addend adds vertical gradients which matches the folded pattern. Third addend adds horizontal gradients when unfolded.\r\n lighting = 0.93 + sin(in_Position.y * TAU_TIMES_TWO) * 0.07 + sin(precalculated_1.w + in_Position.y) * sin(time + in_Position.x * 10.0) * precalculated_2;\r\n}\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_vTexcoord;\r\nvarying 
	float lighting;\r\n\r\nuniform 
	vec4 sprite_uvs;\r\n\r\nvoid 
	main()\r\n{\r\n 
	gl_FragColor = texture2D(gm_BaseTexture, sprite_uvs.xy + v_vTexcoord * sprite_uvs.zw);\r\n 
	gl_FragColor.rgb *= lighting;\r\n}\r\n 
	sh_lut precision mediump float;\n#define 
	LOWPREC lowp\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSLES_ 1\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nuniform 
	sampler2D s_Lut;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 textureColor = texture2D(gm_BaseTexture, v_vTexcoord);\r\n\r\n 
	float Alpha = textureColor.a;\r\n 
	float blueColor = textureColor.b * 63.0;\r\n\r\n 
	vec2 quad1;\r\n 
	quad1.y = floor(floor(blueColor) / 8.0);\r\n 
	quad1.x = floor(blueColor) - (quad1.y * 8.0);\r\n\r\n 
	vec2 quad2;\r\n 
	quad2.y = floor(ceil(blueColor) / 8.0);\r\n 
	quad2.x = ceil(blueColor) - (quad2.y * 8.0);\r\n\r\n 
	vec2 texPos1;\r\n 
	texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\r\n 
	texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\r\n\r\n 
	vec2 texPos2;\r\n 
	texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\r\n 
	texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\r\n\r\n 
	vec4 newColor1 = texture2D(s_Lut, texPos1);\r\n 
	vec4 newColor2 = texture2D(s_Lut, texPos2);\r\n 
	vec4 newColor = mix(newColor1, newColor2, fract(blueColor)); 
	\r\n \r\n gl_FragColor = v_vColour * vec4(newColor.rgb, Alpha);\r\n}\r\n 
	#version 120\n#define LOWPREC \n#define lowp\n#define mediump\n#define highp\n#define precision\n// Uniforms look like they're shared between vertex and fragment shaders in GLSL, so we have to be careful to avoid name clashes\n\nuniform sampler2D gm_BaseTexture;\n\nuniform 
	bool gm_PS_FogEnabled;\nuniform 
	vec4 gm_FogColour;\nuniform 
	bool gm_AlphaTestEnabled;\nuniform 
	float gm_AlphaRefValue;\n\nvoid 
	DoAlphaTest(vec4 SrcColour)\n{\n 
	if (gm_AlphaTestEnabled)\n {\n 
	if (SrcColour.a <= gm_AlphaRefValue)\n {\n 
	discard;\n 
	}\n }\n}\n\nvoid DoFog(inout vec4 SrcColour, float fogval)\n{\n 
	if (gm_PS_FogEnabled)\n {\n 
	SrcColour = mix(SrcColour, gm_FogColour, clamp(fogval, 0.0, 1.0)); 
	\n }\n}\n\n#define _YY_GLSL_ 1\nvarying vec2 v_vTexcoord;\r\nvarying 
	vec4 v_vColour;\r\n\r\nuniform 
	sampler2D s_Lut;\r\n\r\nvoid 
	main()\r\n{\r\n 
	vec4 textureColor = texture2D(gm_BaseTexture, v_vTexcoord);\r\n\r\n 
	float Alpha = textureColor.a;\r\n 
	float blueColor = textureColor.b * 63.0;\r\n\r\n 
	vec2 quad1;\r\n 
	quad1.y = flo 